<?php

namespace App\Controller;

use App\Repository\OrderRepository;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use App\Entity\Course;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use App\Repository\CourseRepository;
use App\Service\CoursePurchaseService; 
use Symfony\Component\Security\Core\User\UserInterface;
use App\Entity\Lesson;
use App\Entity\LessonCompletion;
use App\Entity\CourseCompletion;
use App\Repository\LessonRepository;
use App\Repository\LessonCompletionRepository;
use Doctrine\ORM\EntityManagerInterface;


class LessonController extends AbstractController
{

    private CoursePurchaseService $coursePurchaseService;

    public function __construct(CoursePurchaseService $coursePurchaseService)
    {
        $this->coursePurchaseService = $coursePurchaseService;
    }

    #[Route('/user/courses', name: 'user_courses')]
    public function showPurchasedCourses(CoursePurchaseService $coursePurchaseService): Response
    {
    $user = $this->getUser();

    if (!$user) {
        return $this->redirectToRoute('app_login');
    }

    $purchasedCourses = $coursePurchaseService->getPurchasedCourses($user);

    return $this->render('user/purchased_courses.html.twig', [
        'userPurchasedCourses' => $purchasedCourses,
    ]);
}


    #[Route('/lessons', name: 'app_lesson')]
    public function index(OrderRepository $orderRepository): Response
    {
        $user = $this->getUser();

        if (!$user) {
            // Rediriger vers la connexion si l'utilisateur n'est pas connect√©
            return $this->redirectToRoute('app_login');
        }

        // R√©cup√®re toutes les commandes de l'utilisateur
        $orders = $orderRepository->findBy(['user' => $user]);

        // R√©cup√©rer les cours depuis les produits des commandes
        $courses = [];

        foreach ($orders as $order) {
            foreach ($order->getOrderProducts() as $orderProduct) {
                // R√©cup√©rer le produit associ√© √† l'OrderProduct
                $product = $orderProduct->getProduct();
                dump($product);

                // R√©cup√©rer le cours associ√© √† ce produit
                $course = $product ? $product->getCourse() : null;
                dump($course);

                if ($course && !in_array($course, $courses, true)) {
                    // Si un cours est trouv√© et qu'il n'est pas d√©j√† dans la liste, l'ajouter
                    $courses[] = $course;
                }
            }
        }

        return $this->render('lesson/index.html.twig', [
            'courses' => $courses,
        ]);
    }

    #[Route('/lessons/{id}', name: 'app_lesson_show')]
public function show(
    int $id,
    CourseRepository $courseRepository,
    OrderRepository $orderRepository,
    EntityManagerInterface $em
): Response {
    $user = $this->getUser();
    if (!$user) {
        return $this->redirectToRoute('app_login');
    }

    $course = $courseRepository->find($id);

    if (!$course) {
        throw $this->createNotFoundException('Cours non trouv√©');
    }

    // ‚úÖ V√©rifie si l'utilisateur a bien achet√© ce cours
    $hasPurchased = false;
    foreach ($user->getOrders() as $order) {
        foreach ($order->getOrderItems() as $orderItem) {
            if ($orderItem->getProduct()->getCourse() === $course) {
                $hasPurchased = true;
                break 2;
            }
        }
    }

    if (!$hasPurchased) {
        $this->addFlash('warning', 'Vous devez acheter ce cours pour y acc√©der.');
        return $this->redirectToRoute('app_products');
    }

    // ‚úÖ V√©rifie si toutes les le√ßons sont termin√©es
    $lessons = $course->getLessons();
    $completedLessons = $em->getRepository(LessonCompletion::class)->findBy([
        'user' => $user,
    ]);

    $completedLessonIds = array_map(fn($l) => $l->getLesson()->getId(), $completedLessons);
    $allCompleted = true;

    foreach ($lessons as $lesson) {
        if (!in_array($lesson->getId(), $completedLessonIds)) {
            $allCompleted = false;
            break;
        }
    }

    // ‚úÖ Si toutes les le√ßons sont termin√©es, marquer le cours comme termin√©
    if ($allCompleted) {
        $existing = $em->getRepository(CourseCompletion::class)->findOneBy([
            'user' => $user,
            'course' => $course,
        ]);

        if (!$existing) {
            $completion = new CourseCompletion();
            $completion->setUser($user);
            $completion->setCourse($course);
            $em->persist($completion);
            $em->flush();
        }
    }

    return $this->render('lesson/show.html.twig', [
        'course' => $course,
        'allCompleted' => $allCompleted, // üëà pour Twig
    ]);
}

    #[Route('/user/lessons', name: 'app_user_lesson')]
    public function userCoursesLessons(OrderRepository $orderRepository): Response
    {
        $user = $this->getUser();
      

        if (!$user) {
            throw $this->createAccessDeniedException('Vous devez √™tre connect√© pour acc√©der √† vos le√ßons.');
        }
    
        
        // ‚úÖ R√©cup√©rer toutes les commandes, sans filtrer le statut
        $orders = $orderRepository->findBy([
            'user' => $user,
        ]);

        // V√©rifie si des commandes ont √©t√© trouv√©es
        dump($orders);  // Cela va afficher les commandes dans ton navigateur pour te permettre de v√©rifier
       
        
        // Extraire les cours associ√©s aux produits des commandes
        $courses = [];
        $orderIds = [];  // On va stocker les IDs de commande ici

        
        foreach ($orders as $order) {

             // Ajouter l'ID de la commande √† la liste des IDs
            $orderIds[] = $order->getId();

            foreach ($order->getOrderItems() as $orderItem) {
                $product = $orderItem->getProduct();
                $course = $product ? $product->getCourse() : null;
            
    
                if ($course && !in_array($course, $courses, true)) {
                    // Ajouter le cours √† la liste s'il n'est pas d√©j√† pr√©sent
                    $courses[] = $course;
                }

            }


        }

       
        dump($courses);
        // Passer les cours √† la vue
        return $this->render('user/pending_courses.html.twig', [
            'courses' => $courses,
            'orderIds' => $orderIds,  // Passer les IDs des commandes √† la vue
        ]);
    }

    // 1. Marquer une le√ßon comme termin√©e
    #[Route('/lecon/{id}/terminer', name: 'app_finish_lesson')]
    public function finishLesson(
        Lesson $lesson,
        EntityManagerInterface $em
    ): Response {
        $user = $this->getUser();

        // V√©rifie si la le√ßon est d√©j√† marqu√©e comme termin√©e
        $existing = $em->getRepository(LessonCompletion::class)->findOneBy([
            'user' => $user,
            'lesson' => $lesson
        ]);

        if (!$existing) {
            // Cr√©e une nouvelle entr√©e pour la le√ßon termin√©e
            $completion = new LessonCompletion();
            $completion->setUser($user);
            $completion->setLesson($lesson);
            $em->persist($completion);
            $em->flush();

            $this->addFlash('success', 'Le√ßon marqu√©e comme termin√©e !');
        } else {
            $this->addFlash('info', 'Le√ßon d√©j√† termin√©e.');
        }

        // Redirige l'utilisateur vers la page de ses le√ßons
        return $this->redirectToRoute('app_user_lessons');
    }

    // 2. V√©rifier les le√ßons termin√©es pour chaque cours
    #[Route('/user/lessons', name: 'app_user_lessons')]

    public function userLessons(
        CourseRepository $courseRepository,
        LessonCompletionRepository $lessonCompletionRepository,
        EntityManagerInterface $em
    ): Response {
        $user = $this->getUser();
        
        if (!$user) {
            throw $this->createAccessDeniedException('Vous devez √™tre connect√© pour acc√©der √† vos le√ßons.');
        }

        // R√©cup√©rer les commandes de l'utilisateur
        $orders = $user->getOrders();
        $courses = [];

        foreach ($orders as $order) {
            foreach ($order->getOrderItems() as $orderItem) {
                $product = $orderItem->getProduct();
                $course = $product ? $product->getCourse() : null;

                if ($course && !in_array($course, $courses, true)) {
                    $courses[] = $course;
                }
            }
        }


        $coursesData = [];

        foreach ($courses as $course) {
            $lessons = $course->getLessons();
            $lessonIds = array_map(fn($lesson) => $lesson->getId(), $lessons->toArray());

            // Trouver les le√ßons d√©j√† compl√©t√©es
            $completedLessons = $lessonCompletionRepository->findBy([
                'user' => $user,
            ]);

            // R√©cup√©rer les IDs des le√ßons compl√©t√©es
            $completedLessonIds = array_map(fn($c) => $c->getLesson()->getId(), $completedLessons);

            // V√©rifier si toutes les le√ßons du cours sont termin√©es
            $allCompleted = count($lessonIds) > 0 && empty(array_diff($lessonIds, $completedLessonIds));

            $coursesData[] = [
                'course' => $course,
                'completed' => $allCompleted,
            ];
        }

        // Passer les donn√©es √† la vue
        return $this->render('user/pending_courses.html.twig', [
            'coursesData' => $coursesData,
        ]);
    }

    // 3. Valider un cours
    #[Route('/cours/{id}/valider', name: 'app_validate_course')]
    public function validateCourse(
        Course $course,
        EntityManagerInterface $em
    ): Response {
        $user = $this->getUser();

        // V√©rifier si toutes les le√ßons du cours sont termin√©es
        $lessons = $course->getLessons();
        $completedLessons = $em->getRepository(LessonCompletion::class)
            ->findBy(['user' => $user]);

        $completedLessonIds = array_map(fn($l) => $l->getLesson()->getId(), $completedLessons);

        foreach ($lessons as $lesson) {
            if (!in_array($lesson->getId(), $completedLessonIds)) {
                $this->addFlash('warning', 'Vous devez terminer toutes les le√ßons avant de valider ce cours.');
                return $this->redirectToRoute('app_user_lessons');
            }
        }

        // V√©rifier si le cours est d√©j√† valid√©
        $alreadyCompleted = $em->getRepository(CourseCompletion::class)->findOneBy([
            'user' => $user,
            'course' => $course
        ]);

        if (!$alreadyCompleted) {
            $completion = new CourseCompletion();
            $completion->setUser($user);
            $completion->setCourse($course);
            $em->persist($completion);
            $em->flush();
        }

        $this->addFlash('success', 'Cours valid√© avec succ√®s !');
        return $this->redirectToRoute('app_user_lessons');
    }

    



}


        

